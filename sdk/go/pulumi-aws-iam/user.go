// *** WARNING: this file was generated by Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package pulumiawsiam

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi-aws/sdk/v5/go/aws/iam"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type User struct {
	pulumi.ResourceState

	// The access key associated with the IAM user
	AccessKey iam.AccessKeyOutput `pulumi:"accessKey"`
	// The IAM user
	IamUser iam.UserOutput `pulumi:"iamUser"`
	// The SSH key associated with the IAM user
	SshKey iam.SshKeyOutput `pulumi:"sshKey"`
	// The user login profile associated with the IAM user
	UserLoginProfile iam.UserLoginProfileOutput `pulumi:"userLoginProfile"`
}

// NewUser registers a new resource with the given unique name, arguments, and options.
func NewUser(ctx *pulumi.Context,
	name string, args *UserArgs, opts ...pulumi.ResourceOption) (*User, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CreateIamAccessKey == nil {
		return nil, errors.New("invalid value for required argument 'CreateIamAccessKey'")
	}
	if args.CreateUserLoginProfile == nil {
		return nil, errors.New("invalid value for required argument 'CreateUserLoginProfile'")
	}
	var resource User
	err := ctx.RegisterRemoteComponentResource("awsIam:index:User", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type userArgs struct {
	// Boolean to determine whether to create an IAM access key
	CreateIamAccessKey bool `pulumi:"createIamAccessKey"`
	// Boolean to determine whether to create an IAM user login profile
	CreateUserLoginProfile bool     `pulumi:"createUserLoginProfile"`
	ForceDestroy           *bool    `pulumi:"forceDestroy"`
	PasswordLength         *float64 `pulumi:"passwordLength"`
	PasswordResetRequired  *bool    `pulumi:"passwordResetRequired"`
	Path                   *string  `pulumi:"path"`
	PermissionsBoundary    *string  `pulumi:"permissionsBoundary"`
	PgpKey                 *string  `pulumi:"pgpKey"`
	SshKeyEncoding         *string  `pulumi:"sshKeyEncoding"`
	SshPublicKey           *string  `pulumi:"sshPublicKey"`
	UploadIamUserSshKey    *bool    `pulumi:"uploadIamUserSshKey"`
}

// The set of arguments for constructing a User resource.
type UserArgs struct {
	// Boolean to determine whether to create an IAM access key
	CreateIamAccessKey pulumi.BoolInput
	// Boolean to determine whether to create an IAM user login profile
	CreateUserLoginProfile pulumi.BoolInput
	ForceDestroy           pulumi.BoolPtrInput
	PasswordLength         pulumi.Float64PtrInput
	PasswordResetRequired  pulumi.BoolPtrInput
	Path                   pulumi.StringPtrInput
	PermissionsBoundary    pulumi.StringPtrInput
	PgpKey                 pulumi.StringPtrInput
	SshKeyEncoding         pulumi.StringPtrInput
	SshPublicKey           pulumi.StringPtrInput
	UploadIamUserSshKey    pulumi.BoolPtrInput
}

func (UserArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*userArgs)(nil)).Elem()
}

type UserInput interface {
	pulumi.Input

	ToUserOutput() UserOutput
	ToUserOutputWithContext(ctx context.Context) UserOutput
}

func (*User) ElementType() reflect.Type {
	return reflect.TypeOf((**User)(nil)).Elem()
}

func (i *User) ToUserOutput() UserOutput {
	return i.ToUserOutputWithContext(context.Background())
}

func (i *User) ToUserOutputWithContext(ctx context.Context) UserOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserOutput)
}

// UserArrayInput is an input type that accepts UserArray and UserArrayOutput values.
// You can construct a concrete instance of `UserArrayInput` via:
//
//          UserArray{ UserArgs{...} }
type UserArrayInput interface {
	pulumi.Input

	ToUserArrayOutput() UserArrayOutput
	ToUserArrayOutputWithContext(context.Context) UserArrayOutput
}

type UserArray []UserInput

func (UserArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*User)(nil)).Elem()
}

func (i UserArray) ToUserArrayOutput() UserArrayOutput {
	return i.ToUserArrayOutputWithContext(context.Background())
}

func (i UserArray) ToUserArrayOutputWithContext(ctx context.Context) UserArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserArrayOutput)
}

// UserMapInput is an input type that accepts UserMap and UserMapOutput values.
// You can construct a concrete instance of `UserMapInput` via:
//
//          UserMap{ "key": UserArgs{...} }
type UserMapInput interface {
	pulumi.Input

	ToUserMapOutput() UserMapOutput
	ToUserMapOutputWithContext(context.Context) UserMapOutput
}

type UserMap map[string]UserInput

func (UserMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*User)(nil)).Elem()
}

func (i UserMap) ToUserMapOutput() UserMapOutput {
	return i.ToUserMapOutputWithContext(context.Background())
}

func (i UserMap) ToUserMapOutputWithContext(ctx context.Context) UserMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserMapOutput)
}

type UserOutput struct{ *pulumi.OutputState }

func (UserOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**User)(nil)).Elem()
}

func (o UserOutput) ToUserOutput() UserOutput {
	return o
}

func (o UserOutput) ToUserOutputWithContext(ctx context.Context) UserOutput {
	return o
}

type UserArrayOutput struct{ *pulumi.OutputState }

func (UserArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*User)(nil)).Elem()
}

func (o UserArrayOutput) ToUserArrayOutput() UserArrayOutput {
	return o
}

func (o UserArrayOutput) ToUserArrayOutputWithContext(ctx context.Context) UserArrayOutput {
	return o
}

func (o UserArrayOutput) Index(i pulumi.IntInput) UserOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *User {
		return vs[0].([]*User)[vs[1].(int)]
	}).(UserOutput)
}

type UserMapOutput struct{ *pulumi.OutputState }

func (UserMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*User)(nil)).Elem()
}

func (o UserMapOutput) ToUserMapOutput() UserMapOutput {
	return o
}

func (o UserMapOutput) ToUserMapOutputWithContext(ctx context.Context) UserMapOutput {
	return o
}

func (o UserMapOutput) MapIndex(k pulumi.StringInput) UserOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *User {
		return vs[0].(map[string]*User)[vs[1].(string)]
	}).(UserOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UserInput)(nil)).Elem(), &User{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserArrayInput)(nil)).Elem(), UserArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserMapInput)(nil)).Elem(), UserMap{})
	pulumi.RegisterOutputType(UserOutput{})
	pulumi.RegisterOutputType(UserArrayOutput{})
	pulumi.RegisterOutputType(UserMapOutput{})
}
