// *** WARNING: this file was generated by Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package pulumiawsiam

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type AssumableRole struct {
	pulumi.ResourceState

	// Amazon Resource Name (ARN) specifying the role.
	Arn pulumi.StringOutput `pulumi:"arn"`
	// Creation date of the IAM role.
	CreateDate pulumi.StringOutput `pulumi:"createDate"`
	// The provider-assigned unique ID for this managed resource..
	Id pulumi.StringOutput `pulumi:"id"`
	// Stable and unique string identifying the role.
	UniqueId pulumi.StringOutput `pulumi:"uniqueId"`
}

// NewAssumableRole registers a new resource with the given unique name, arguments, and options.
func NewAssumableRole(ctx *pulumi.Context,
	name string, args *AssumableRoleArgs, opts ...pulumi.ResourceOption) (*AssumableRole, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AssumeRolePolicy == nil {
		return nil, errors.New("invalid value for required argument 'AssumeRolePolicy'")
	}
	var resource AssumableRole
	err := ctx.RegisterRemoteComponentResource("awsIam:index:AssumableRole", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type assumableRoleArgs struct {
	// Policy that grants an entity permission to assume the role.
	AssumeRolePolicy string `pulumi:"assumeRolePolicy"`
	// Whether to attach a predefined aws admin policy
	AttachAdminPolicy *bool `pulumi:"attachAdminPolicy"`
	// Whether to attach a predefined aws poweruser policy
	AttachPowerUserPolicy *bool `pulumi:"attachPowerUserPolicy"`
	// Whether to attach a predefined aws readonly policy
	AttachReadOnlyPolicy *bool `pulumi:"attachReadOnlyPolicy"`
}

// The set of arguments for constructing a AssumableRole resource.
type AssumableRoleArgs struct {
	// Policy that grants an entity permission to assume the role.
	AssumeRolePolicy pulumi.StringInput
	// Whether to attach a predefined aws admin policy
	AttachAdminPolicy pulumi.BoolPtrInput
	// Whether to attach a predefined aws poweruser policy
	AttachPowerUserPolicy pulumi.BoolPtrInput
	// Whether to attach a predefined aws readonly policy
	AttachReadOnlyPolicy pulumi.BoolPtrInput
}

func (AssumableRoleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*assumableRoleArgs)(nil)).Elem()
}

type AssumableRoleInput interface {
	pulumi.Input

	ToAssumableRoleOutput() AssumableRoleOutput
	ToAssumableRoleOutputWithContext(ctx context.Context) AssumableRoleOutput
}

func (*AssumableRole) ElementType() reflect.Type {
	return reflect.TypeOf((**AssumableRole)(nil)).Elem()
}

func (i *AssumableRole) ToAssumableRoleOutput() AssumableRoleOutput {
	return i.ToAssumableRoleOutputWithContext(context.Background())
}

func (i *AssumableRole) ToAssumableRoleOutputWithContext(ctx context.Context) AssumableRoleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AssumableRoleOutput)
}

// AssumableRoleArrayInput is an input type that accepts AssumableRoleArray and AssumableRoleArrayOutput values.
// You can construct a concrete instance of `AssumableRoleArrayInput` via:
//
//          AssumableRoleArray{ AssumableRoleArgs{...} }
type AssumableRoleArrayInput interface {
	pulumi.Input

	ToAssumableRoleArrayOutput() AssumableRoleArrayOutput
	ToAssumableRoleArrayOutputWithContext(context.Context) AssumableRoleArrayOutput
}

type AssumableRoleArray []AssumableRoleInput

func (AssumableRoleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AssumableRole)(nil)).Elem()
}

func (i AssumableRoleArray) ToAssumableRoleArrayOutput() AssumableRoleArrayOutput {
	return i.ToAssumableRoleArrayOutputWithContext(context.Background())
}

func (i AssumableRoleArray) ToAssumableRoleArrayOutputWithContext(ctx context.Context) AssumableRoleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AssumableRoleArrayOutput)
}

// AssumableRoleMapInput is an input type that accepts AssumableRoleMap and AssumableRoleMapOutput values.
// You can construct a concrete instance of `AssumableRoleMapInput` via:
//
//          AssumableRoleMap{ "key": AssumableRoleArgs{...} }
type AssumableRoleMapInput interface {
	pulumi.Input

	ToAssumableRoleMapOutput() AssumableRoleMapOutput
	ToAssumableRoleMapOutputWithContext(context.Context) AssumableRoleMapOutput
}

type AssumableRoleMap map[string]AssumableRoleInput

func (AssumableRoleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AssumableRole)(nil)).Elem()
}

func (i AssumableRoleMap) ToAssumableRoleMapOutput() AssumableRoleMapOutput {
	return i.ToAssumableRoleMapOutputWithContext(context.Background())
}

func (i AssumableRoleMap) ToAssumableRoleMapOutputWithContext(ctx context.Context) AssumableRoleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AssumableRoleMapOutput)
}

type AssumableRoleOutput struct{ *pulumi.OutputState }

func (AssumableRoleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AssumableRole)(nil)).Elem()
}

func (o AssumableRoleOutput) ToAssumableRoleOutput() AssumableRoleOutput {
	return o
}

func (o AssumableRoleOutput) ToAssumableRoleOutputWithContext(ctx context.Context) AssumableRoleOutput {
	return o
}

type AssumableRoleArrayOutput struct{ *pulumi.OutputState }

func (AssumableRoleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AssumableRole)(nil)).Elem()
}

func (o AssumableRoleArrayOutput) ToAssumableRoleArrayOutput() AssumableRoleArrayOutput {
	return o
}

func (o AssumableRoleArrayOutput) ToAssumableRoleArrayOutputWithContext(ctx context.Context) AssumableRoleArrayOutput {
	return o
}

func (o AssumableRoleArrayOutput) Index(i pulumi.IntInput) AssumableRoleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AssumableRole {
		return vs[0].([]*AssumableRole)[vs[1].(int)]
	}).(AssumableRoleOutput)
}

type AssumableRoleMapOutput struct{ *pulumi.OutputState }

func (AssumableRoleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AssumableRole)(nil)).Elem()
}

func (o AssumableRoleMapOutput) ToAssumableRoleMapOutput() AssumableRoleMapOutput {
	return o
}

func (o AssumableRoleMapOutput) ToAssumableRoleMapOutputWithContext(ctx context.Context) AssumableRoleMapOutput {
	return o
}

func (o AssumableRoleMapOutput) MapIndex(k pulumi.StringInput) AssumableRoleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AssumableRole {
		return vs[0].(map[string]*AssumableRole)[vs[1].(string)]
	}).(AssumableRoleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AssumableRoleInput)(nil)).Elem(), &AssumableRole{})
	pulumi.RegisterInputType(reflect.TypeOf((*AssumableRoleArrayInput)(nil)).Elem(), AssumableRoleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AssumableRoleMapInput)(nil)).Elem(), AssumableRoleMap{})
	pulumi.RegisterOutputType(AssumableRoleOutput{})
	pulumi.RegisterOutputType(AssumableRoleArrayOutput{})
	pulumi.RegisterOutputType(AssumableRoleMapOutput{})
}
